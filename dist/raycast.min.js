var raycast =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ts_raycasting_1 = __webpack_require__(2);
	var EState_1 = __webpack_require__(4);
	var Level01_1 = __webpack_require__(5);
	var Actor_1 = __webpack_require__(6);
	var Render_1 = __webpack_require__(8);
	var state = EState_1["default"].INIT;
	var currentLevel = Level01_1["default"];
	// first, get elements from DOM
	var canvasEl = document.getElementById('canvas');
	var ctx = canvasEl.getContext('2d');
	var texturesEl = document.getElementById('textures');
	var textureSize = 64;
	// set up key events
	var keyDown = null;
	var keyPressed = null;
	var keyUp = null;
	document.onkeypress = function (event) {
	    event = event || window.event;
	    keyPressed = event.keyCode;
	};
	document.onkeydown = function (event) {
	    event = event || window.event;
	    keyDown = event.keyCode;
	};
	document.onkeyup = function (event) {
	    event = event || window.event;
	    keyUp = event.keyCode;
	};
	// clear inputs
	var clearInputs = function () {
	    keyDown = null;
	    keyPressed = null;
	    keyUp = null;
	};
	state = EState_1["default"].LOADING;
	var fps = 1000 / 30;
	var player = Actor_1.createActor(currentLevel.start[0], currentLevel.start[1]);
	var tick = function () {
	    console.log('.');
	    switch (keyDown) {
	        case 37:
	            player.rot -= Math.PI / 12;
	            break;
	        case 39:
	            player.rot += Math.PI / 12;
	            break;
	        case 38:
	            var nx = Math.cos(player.rot) * player.speed;
	            var ny = Math.sin(player.rot) * player.speed;
	            if (currentLevel.map[Math.floor(player.y + ny)][Math.floor(player.x + nx)] === 0) {
	                player.x += nx;
	                player.y += ny;
	            }
	            break;
	    }
	    var rays = ts_raycasting_1["default"].castRays(currentLevel.map, player.x, player.y, player.rot, function (row, column) {
	        if (currentLevel.map[row][column] !== 0) {
	            return false;
	        }
	        return true;
	    });
	    Render_1["default"].renderBackground(ctx, 256, 300);
	    Render_1["default"].renderRays(texturesEl, textureSize, ctx, 256, 300, currentLevel.map, rays);
	    // rays.forEach((ray, index) => {
	    //     ctx.fillStyle = "blue";
	    //     ctx.fillRect(index, 150 - (player.height/ray.dist), 1, 2 * (player.height/ray.dist));
	    // });
	    clearInputs();
	    setTimeout(tick, fps);
	};
	state = EState_1["default"].RUNNING;
	tick();


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var _this = this;
	var Utils_1 = __webpack_require__(3);
	// default castRays configuration
	var defaultConfig = {
	    count: 256,
	    fov: 60,
	    fisheye: false
	};
	/**
	 * Cast one ray from position until test fails
	 * @param {Array<Array<number>>} map - 2d world on which will be casted ray
	 * @param {number} x - coordinate in map
	 * @param {number} y - coordinate in map
	 * @param {testintersection} intersection - test function is called on every intersection. If fails, fuction will return IRay
	 * @param {number} rayRot - rot of ray in radians
	 * @return {IRay} information about ray, check IRay type
	 */
	exports.castRay = function (map, x, y, intersection, rayRot) {
	    var angleSin = Math.sin(rayRot);
	    var angleCos = Math.cos(rayRot);
	    var quadrant = Utils_1.getQuadrant(rayRot); // in which quadrant is ray looking to
	    // current cell position in map
	    var column = Math.floor(x);
	    var row = Math.floor(y);
	    var hSlope = (angleSin / angleCos); // tan
	    var vSlope = (angleCos / angleSin); // ctan
	    // horizontal intersection with cell
	    var stepX = (quadrant.right) ? 1 : -1;
	    var hdY = stepX * hSlope;
	    // vertical intersection with cell
	    var stepY = (quadrant.top) ? -1 : 1;
	    var vdX = stepY * vSlope;
	    // first horizontal intesection world coordinates in world
	    var hHitX = (quadrant.right) ? Math.ceil(x) : column;
	    var hHitY = y + ((hHitX - x) * hSlope);
	    // first vertical intersection world coordinates in world
	    var vHitY = (quadrant.top) ? row : Math.ceil(y);
	    var vHitX = x + ((vHitY - y) * vSlope);
	    // distance from current point to nearest x || y side
	    var sideDistX = Math.sqrt(Math.pow((hHitX - x), 2) + Math.pow((hHitY - y), 2));
	    var sideDistY = Math.sqrt(Math.pow((vHitX - x), 2) + Math.pow((vHitY - y), 2));
	    // distance from x || y  side to another x || y side
	    var deltaDistX = Math.sqrt(Math.pow(stepX, 2) + Math.pow(hdY, 2));
	    var deltaDistY = Math.sqrt(Math.pow(vdX, 2) + Math.pow(stepY, 2));
	    var side = (sideDistX < sideDistY) ? 0 : 1; // NS or WE wall hit ?
	    var dist = (sideDistX < sideDistY) ? sideDistX : sideDistY; // initial distance from caster to intersection
	    var i = 0; // number of intersections
	    // @todo send hitX and hitY to test function
	    while (intersection(row, column, dist, i)) {
	        if (sideDistX < sideDistY) {
	            sideDistX += deltaDistX;
	            hHitX += stepX;
	            hHitY += hdY;
	            // vars passed to testfunction
	            column += stepX;
	            dist = sideDistX;
	            side = 0;
	        }
	        else {
	            sideDistY += deltaDistY;
	            vHitX += vdX;
	            vHitY += stepY;
	            // vars passed to testfunction
	            row += stepY;
	            dist = sideDistY;
	            side = 1;
	        }
	        i++;
	    }
	    return {
	        // ray distance from caster
	        dist: (!side)
	            ? (sideDistX - deltaDistX)
	            : (sideDistY - deltaDistY),
	        // side, which was hit. NS or WE
	        side: side,
	        // ray x hit
	        x: (side)
	            ? (vHitX - vdX)
	            : (hHitX - stepX),
	        // ray y hit
	        y: (side)
	            ? (vHitY - stepY)
	            : (hHitY - hdY),
	        // ray rot
	        rot: rayRot,
	        // ray row hit
	        row: row,
	        // ray column hit
	        column: column
	    };
	};
	/**
	 * Cast rays from position in world
	 * @param {Array<Array<number>>} map - 2d world on which will be casted ray
	 * @param {number} x - camera coordinate in map
	 * @param {number} y - camera coordinate in map
	 * @param {testintersection} intersection - this function is called on every ray's intersection. If fail, fuction will return IRay
	 * @param {IRayConf} config - additional configuration
	 * @return {Array<IRay>} all rays casted from position, check IRay type
	 */
	exports.castRays = function (map, x, y, rot, intersection, config) {
	    if (config === void 0) { config = defaultConfig; }
	    var castRayFromPosition = exports.castRay.bind(_this, map, x, y, intersection);
	    var dRot = (Math.PI / (180 / config.fov)) / config.count; // difference between each ray rot
	    var center = rot - dRot * (config.count / 2) + (dRot / 2);
	    var rays = []; // casted rays
	    var i = 0;
	    if (config.fisheye) {
	        while (i < config.count) {
	            // it's important to normalize rot before casting it, to make sure that rot will continue in direction
	            rays.push(castRayFromPosition(Utils_1.normalizeAngle(i * dRot + center)));
	            i++;
	        }
	    }
	    else {
	        while (i < config.count) {
	            // it's important to normalize rot before casting it, to make sure that rot will continue in direction
	            // also remove fisheye effect
	            rays.push(Utils_1.removeFisheye(castRayFromPosition(Utils_1.normalizeAngle(i * dRot + center)), rot));
	            i++;
	        }
	    }
	    return rays;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = {
	    castRay: exports.castRay,
	    castRays: exports.castRays
	};


/***/ },
/* 3 */
/***/ function(module, exports) {

	"use strict";
	var twoPI = Math.PI * 2;
	var halfPI = Math.PI * 0.5;
	var oneAndHalfPI = twoPI * 0.75;
	/**
	 * From which quadrant are we looking out ?
	 * @param {number} rot
	 * @return {IQuadrant}
	 */
	exports.getQuadrant = function (rot) { return ({
	    top: ((rot < 0) || (rot > Math.PI)) ? true : false,
	    right: ((rot > oneAndHalfPI) || (rot < halfPI)) ? true : false
	}); };
	/**
	 * Normalize angle to be between <0, 2*Math.Pi>
	 * @param {number} rot - rot to normalize, in radians
	 * @return {number} normalized rot
	 */
	exports.normalizeAngle = function (rot) {
	    var rayAngle = rot % twoPI;
	    return (rayAngle < 0)
	        ? twoPI + rayAngle
	        : rayAngle;
	};
	/**
	 * Remove fisheye effect
	 * @param {IRay} ray - ray to fix
	 * @param {number} camRot - camera rot
	 * @return {IRay} fixed ray
	 */
	exports.removeFisheye = function (ray, camRot) {
	    ray.dist = ray.dist * Math.cos(camRot - ray.rot);
	    return ray;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = {
	    getQuadrant: exports.getQuadrant,
	    normalizeAngle: exports.normalizeAngle,
	    removeFisheye: exports.removeFisheye
	};


/***/ },
/* 4 */
/***/ function(module, exports) {

	"use strict";
	(function (EState) {
	    EState[EState["INIT"] = 0] = "INIT";
	    EState[EState["LOADING"] = 1] = "LOADING";
	    EState[EState["RUNNING"] = 2] = "RUNNING";
	    EState[EState["STOP"] = 3] = "STOP";
	})(exports.EState || (exports.EState = {}));
	var EState = exports.EState;
	;
	exports.__esModule = true;
	exports["default"] = EState;


/***/ },
/* 5 */
/***/ function(module, exports) {

	"use strict";
	exports.Level01 = {
	    map: [
	        [1, 2, 2, 4, 4, 4, 1, 1, 1, 1, 1, 1],
	        [1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 3],
	        [2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 3],
	        [1, 0, 0, 0, 0, 1, 4, 2, 1, 0, 0, 3],
	        [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],
	        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],
	        [1, 2, 0, 0, 1, 2, 0, 0, 1, 1, 0, 3],
	        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],
	        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],
	        [1, 0, 0, 0, 0, 1, 4, 4, 1, 0, 0, 3],
	        [1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 3],
	        [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 3],
	        [1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1]
	    ],
	    start: [3.5, 3.5]
	};
	exports.__esModule = true;
	exports["default"] = exports.Level01;


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var EPlayerState_1 = __webpack_require__(7);
	exports.createActor = function (x, y) {
	    if (x === void 0) { x = 0; }
	    if (y === void 0) { y = 0; }
	    return ({
	        x: x,
	        y: y,
	        rot: 0.1,
	        rotSpeed: (Math.PI / 12),
	        height: 80,
	        speed: 0.5,
	        state: EPlayerState_1["default"].STAND
	    });
	};
	exports.__esModule = true;
	exports["default"] = exports.createActor;


/***/ },
/* 7 */
/***/ function(module, exports) {

	"use strict";
	(function (EPlayerState) {
	    EPlayerState[EPlayerState["STAND"] = 0] = "STAND";
	    EPlayerState[EPlayerState["MOVE"] = 1] = "MOVE";
	    EPlayerState[EPlayerState["ROTATE"] = 2] = "ROTATE";
	})(exports.EPlayerState || (exports.EPlayerState = {}));
	var EPlayerState = exports.EPlayerState;
	;
	exports.__esModule = true;
	exports["default"] = EPlayerState;


/***/ },
/* 8 */
/***/ function(module, exports) {

	"use strict";
	exports.renderBackground = function (ctx, width, height) {
	    var half = Math.floor(height / 2);
	    ctx.fillStyle = "black";
	    ctx.fillRect(0, 0, width, half);
	    ctx.fillStyle = "grey";
	    ctx.fillRect(0, half, width, half);
	};
	exports.renderRays = function (textures, textureSize, ctx, width, height, map, rays) {
	    var half = Math.floor(height / 2);
	    rays.forEach(function (ray, index) {
	        var tileId = map[ray.row][ray.column];
	        if (ray.side) {
	            ctx.drawImage(textures, (ray.x - Math.floor(ray.x)) * textureSize, (tileId * textureSize - textureSize), 1, textureSize, index, half - (80 / ray.dist), 1, 2 * (80 / ray.dist));
	        }
	        else {
	            ctx.drawImage(textures, (ray.y - Math.floor(ray.y)) * textureSize, (tileId * textureSize - textureSize), 1, textureSize, index, half - (80 / ray.dist), 1, 2 * (80 / ray.dist));
	        }
	    });
	};
	exports.__esModule = true;
	exports["default"] = {
	    renderBackground: exports.renderBackground,
	    renderRays: exports.renderRays
	};


/***/ }
/******/ ]);